<!DOCTYPE html>
<html>
<head>
	<script src="phaser.js"></script>
	<title>hive mind</title>
	<style>
		p#camdata {
			position: absolute;
			color: white;
		}
	</style>
</head>
<body>
	<form id="login">
        <div class="form-control">
            <label for="UUID">UUID</label>
            <input
            type="text"
            name="UUID"
            id="UUID"
            placeholder="Enter UUID"
            autocomplete="off"
            required
            />
        </div>
        <div class="form-control">
            <label for="token">token</label>
            <input
            type="text"
            name="token"
            id="token"
            placeholder="Enter token"
            autocomplete="off"
            required
            />
        </div>
        <button type="submit">start</button>
    </form>
</body>
<script>
var myUUID
var activeDroneUUIDs = []
var socket
var lastFrameTime
var cam

var keysPressed = {}
var activeCharacters = {}
var projectiles = {}
var camPos = {
	x: 0,
	y: 0,
}

var pressed_keys = []
var socket_stream = [
	// {
	// 	type: "makeDrone",
	// }
]

// I wasted so much time typing in my UUID and token Before I added this
document.querySelector("#UUID").value = localStorage.getItem("UUID")
document.querySelector("#token").value = localStorage.getItem("token")

// start the game
document.querySelector("#login").addEventListener('submit', (e) => {
	e.preventDefault(); // forms usually reload the webpage
	const UUID = e.target.elements.UUID.value.trim()
	const token = e.target.elements.token.value.trim()
	
	if (UUID && token) {
		// store UUID and token for later
		localStorage.setItem("UUID", UUID)
		localStorage.setItem("token", token)

		myUUID = localStorage.getItem("UUID")
		document.querySelector("body").innerHTML = `<p id="camdata"></p>`
		start()
	} else {
		document.querySelector("body").innerHTML = "could not get your UUID or token"
	}
});

// get the distance between point1 and point2
function getDistance(point1, point2) {
	return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
}

// for getting the delta time in a loop
function secondsSinceLastFrame() {
	if (lastFrameTime == 0) {
		lastFrameTime = Date.now();
		return 0;
	}
	const currentTime = lastFrameTime;
	lastFrameTime = Date.now();
	return (lastFrameTime - currentTime) / 1000;
}

// Work in progress function to smooth out unpredictability and lag in the netwerk
function smooth(DeltaTime, sprite, x, y) {
	x = x * 32
	y = y * 32
	const distance = getDistance(
		{ x: sprite.x, y: sprite.y }, 
		{ x: x, y: y }
	)
	if (distance > 3) {
		let distanceToTravel = DeltaTime + 3;
		const angle = Math.atan2(y - sprite.y, x - sprite.x);

		sprite.x += distanceToTravel * Math.cos(angle)
		sprite.y += distanceToTravel * Math.sin(angle)
	} else if (distance <= 3) {
		let distanceToTravel = DeltaTime + distance / 10;
		const angle = Math.atan2(y - sprite.y, x - sprite.x);

		sprite.x += distanceToTravel * Math.cos(angle)
		sprite.y += distanceToTravel * Math.sin(angle)
	}
}

class Example extends Phaser.Scene {
	constructor() {
		super();
	}

	preload() {
		// preload images

		// environment

		// Characters
		this.load.image('player', 'assets/player.png');
		this.load.image('projectile', 'assets/projectile.png');

		// nodes
		this.load.image('copper-wall', 'assets/copper-wall.png');
	}

	create() {
		this.add.image(0, 0, 'copper-wall');
		this.add.image(0, 32, 'copper-wall');

		this.add.image(32, 0, 'copper-wall');
		this.add.image(32, 32, 'copper-wall');

		// create a web socket at wss://quiet-inquisitive-epoch.glitch.me
		this.socket = new WebSocket(
			`wss://quiet-inquisitive-epoch.glitch.me`,
			[myUUID, localStorage.getItem("token"), "1.0.0"] // Ugly hack to send auth information and version to the server.
		);

		// Listen for messages
		this.socket.addEventListener('message', (event) => {
			const updates = JSON.parse(event.data)
			// uncomment the line below to log all updates from the server
			// console.log('updates from server ', updates);

			updates.forEach(update => {
				const data = update.data
				switch (update.type) {
					case "drone": // information about a drone
						const existingCharacter = activeCharacters[data.UUID]
						if (existingCharacter) {
							existingCharacter.gameState = data
						} else {
							const sprite = this.add.image(data.x * 32, data.y * 32, 'player')//.setDisplaySize(100, 100);
							activeCharacters[data.UUID] = {
								ownerUUID: data.ownerUUID,
								sprite: sprite,
								gameState: data,
							}
							if (data.ownerUUID == myUUID) {
								activeDroneUUIDs.push(data.UUID)
							}
						}
						break;
					case "noDrone": // drone no longer exists TODO: have the server give more information about why the drone is gone
						const droneToRm = activeCharacters[data.UUID]
						if (!droneToRm) return console.error("no droneToRm?", update)
						droneToRm.sprite.destroy()
						delete activeCharacters[data.UUID]
						break;
					case "pro": // a projectile exists
						const projectile = projectiles[data.id]
						if (projectile) {
							projectile.gameState = data
						} else {
							const sprite = this.add.image(data.x * 32, data.y * 32, 'projectile')
							projectiles[data.id] = {
								sprite: sprite,
								gameState: data,
							}
						}
						break;
					case "noPro": // a projectile no longer exists
						const proToRm = projectiles[data.id]
						if (!proToRm) return console.error("no proToRm?", update)
						proToRm.sprite.destroy()
						delete projectiles[data.id]
						break;
				
					default:
						break;
				}
			});
		});

		this.input.keyboard.on('keydown', (event) => {
			if (event.key == " ") {
				socket_stream.push({
					type: "move",
					data: {
						DUUID: activeDroneUUIDs[0],
						x: camPos.x / 32,
						y: camPos.y / 32,
					},
				})
			}
			keysPressed[event.key] = true
		});
		this.input.keyboard.on('keyup', (event) => {
			keysPressed[event.key] = undefined
		});
		this.input.on(Phaser.Input.Events.POINTER_DOWN, (pointer) => {
			const { worldX, worldY } = pointer
			
			for (let i = 0; i < activeDroneUUIDs.length; i++) {
				const drone = activeCharacters[activeDroneUUIDs[i]]
				socket_stream.push({
					type: "shoot",
					data: {
						DUUID: activeDroneUUIDs[i],
						rad: Math.atan2(worldY / 32 - drone.gameState.y, worldX / 32 - drone.gameState.x),
					},
				})
			}
		})
		this.input.on(Phaser.Input.Events.POINTER_UP, (pointer) => {
			const { worldX, worldY } = pointer
			
			for (let i = 0; i < activeDroneUUIDs.length; i++) {
				const drone = activeCharacters[activeDroneUUIDs[i]]
				socket_stream.push({
					type: "shoot",
					data: {
						DUUID: activeDroneUUIDs[i],
					},
				})
			}
		})
		cam = this.cameras.main
		cam.zoom = 1.5
		this.loop()
	}

	// 10 Times a second
	// if socket_stream has something socket.emit it
	loop() {
		if (this.socket.readyState == 1 && socket_stream.length != 0) {
			let actions = socket_stream.slice(0, 10)
			socket_stream.splice(0, 10)
			console.log("actions", actions)

			this.socket.send(JSON.stringify(actions))
		}
		setTimeout(() => { this.loop() }, 100); // continue the loop
	}

	// this runs every frame
	update() {
		const DeltaTime = secondsSinceLastFrame()

		// Smooth movement for projectiles and characters
		for (const key in projectiles) {
			const pro = projectiles[key];
			smooth(DeltaTime, pro.sprite, pro.gameState.x, pro.gameState.y)
		}
		for (const key in activeCharacters) {
			const character = activeCharacters[key];
			smooth(DeltaTime, character.sprite, character.gameState.x, character.gameState.y)
		}
		
		// Control over the camera
		const u = keysPressed["w"] // up
		const d = keysPressed["s"] // down
		const l = keysPressed["a"] // left
		const r = keysPressed["d"] // right

		// if a control
		if (u || d || l || r) {
			// do nothing for opposite controls
			if (u && d && l && r) {
				return
			} else if (u && d && !l && !r) {
				return
			} else if (!u && !d && l && r) {
				return
			}
			// update camera
			if (u) camPos.y -= 5
			if (d) camPos.y += 5
			if (l) camPos.x -= 5
			if (r) camPos.x += 5
		}

		if (!cam) return
		cam.pan(camPos.x, camPos.y, 100, 'Linear')
		document.querySelector("#camdata").innerHTML = `${camPos.x} ${camPos.y}`
	}
}

// start the game
function start() {

	var scene = new Example()

	var game = new Phaser.Game({
		type: Phaser.AUTO,
		width: 800,
		height: 600,
		scene: [ scene ]
	});
}
</script>
</html>