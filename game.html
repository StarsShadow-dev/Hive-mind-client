<!DOCTYPE html>
<html>
<head>
	<script src="phaser.js"></script>
	<title>hive mind</title>
	<style>
		p#camdata {
			position: absolute;
			color: white;
		}

		#chat_container {
			position: absolute;
		}

		#chat_messages {
			resize: vertical;
			height: 100px;
			overflow: scroll;
			border: 1px solid black;
			width: 300px;
		}

		#chat_form {
			position: absolute;
		}

		.message {
			background-color: aqua;
			border: 1px solid gray;
		}

		.message:hover {
			background-color: #c6cade;
		}

		.message p .username {
			color: white;
		}

		.message p .msg {
			color: white;
		}
	</style>
</head>
<body>
	<form id="login">
        <div class="form-control">
            <label for="UUID">UUID</label>
            <input
            type="text"
            name="UUID"
            id="UUID"
            placeholder="Enter UUID"
            autocomplete="off"
            required
            />
        </div>
        <div class="form-control">
            <label for="pass">pass</label>
            <input
            type="text"
            name="pass"
            id="pass"
            placeholder="Enter 1 time pass"
            autocomplete="off"
            required
            />
        </div>
        <button type="submit">start</button>
    </form>
</body>
<script>
var pass
var myUUID
var activeDroneUUIDs = []
var socket
var lastFrameTime
var cam

var keysPressed = {}
var activeCharacters = {}
var projectiles = {}
var camPos = {
	x: 0,
	y: 0,
}

var pressed_keys = []
var socket_stream = [
	// {
	// 	type: "makeDrone",
	// }
]

let chat_messages

// I wasted so much time typing in my UUID Before I added this
document.querySelector("#UUID").value = localStorage.getItem("UUID")

// start the game
document.querySelector("#login").addEventListener('submit', (e) => {
	e.preventDefault(); // forms usually reload the webpage
	const UUID = e.target.elements.UUID.value.trim()
	pass = e.target.elements.pass.value.trim()
	
	if (UUID && pass) {
		// store UUID for later
		localStorage.setItem("UUID", UUID)

		myUUID = localStorage.getItem("UUID")
		document.querySelector("body").innerHTML = `
		<p id="camdata"></p>
		<div id="chat_container">
			<div id="chat_messages"></div>
			<div id="chat_form">
				<form id="chat-form">
				<input
					id="msg"
					type="text"
					placeholder="Type a Message"
					autocomplete="off"
					required
				/>
				<button id="message-submit">send</button>
				</form>
			</div>
		</div>
		`
		chat_messages = document.querySelector("#chat_messages")
		start()
	} else {
		document.querySelector("body").innerHTML = "could not get your UUID or pass"
	}
});

// get the distance between point1 and point2
function getDistance(point1, point2) {
	return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
}

// for getting the delta time in a loop
function secondsSinceLastFrame() {
	if (lastFrameTime == 0) {
		lastFrameTime = Date.now();
		return 0;
	}
	const currentTime = lastFrameTime;
	lastFrameTime = Date.now();
	return (lastFrameTime - currentTime) / 1000;
}

// -work in progress- function to smooth out unpredictability and lag in the netwerk
function smooth(DeltaTime, sprite, speed, x, y) {
	const distance = getDistance(
		{ x: sprite.x, y: sprite.y }, 
		{ x: x, y: y }
	)
	let distanceToTravel = DeltaTime + distance / 10;
	const angle = Math.atan2(y - sprite.y, x - sprite.x);

	sprite.x += distanceToTravel * Math.cos(angle)
	sprite.y += distanceToTravel * Math.sin(angle)
	// if (distance > speed) {
	// 	let distanceToTravel = DeltaTime + speed;
	// 	const angle = Math.atan2(y - sprite.y, x - sprite.x);

	// 	sprite.x += distanceToTravel * Math.cos(angle)
	// 	sprite.y += distanceToTravel * Math.sin(angle)
	// } else if (distance <= speed) { // at the end of the movement will be more precise but may cause other issues
	// 	let distanceToTravel = DeltaTime + distance / 10;
	// 	const angle = Math.atan2(y - sprite.y, x - sprite.x);

	// 	sprite.x += distanceToTravel * Math.cos(angle)
	// 	sprite.y += distanceToTravel * Math.sin(angle)
	// }
}

function outputMessage(name, msg) {
	let movedown = false
	if (chat_messages.clientHeight + chat_messages.scrollTop >= chat_messages.scrollHeight) {
		movedown = true
	}
	const div = document.createElement('div');
	div.classList.add('message');
	div.ondblclick
	// div.oncontextmenu = (e) => {
	// 	e.preventDefault()
	// 	e.srcElement
	// 	console.log(e)
	// }
	const p = document.createElement('p');
	p.classList.add('username');
	p.innerText = name
	div.appendChild(p);
	const para = document.createElement('p');
	para.classList.add('msg');
	para.innerText = msg;
	div.appendChild(para);
	chat_messages.append(div);
	if (movedown) {
		chat_messages.scrollTop = chat_messages.scrollHeight; // Scroll down
	}
}

class Example extends Phaser.Scene {
	constructor() {
		super();
	}

	preload() {
		// preload images

		// environment

		// Characters
		this.load.image('player', 'assets/player.png');
		this.load.image('projectile', 'assets/projectile.png');

		// nodes
		this.load.image('copper-wall', 'assets/copper-wall.png');
	}

	create() {
		this.add.image(0, 0, 'copper-wall');
		this.add.image(0, 32, 'copper-wall');

		this.add.image(32, 0, 'copper-wall');
		this.add.image(32, 32, 'copper-wall');

		// create a web socket
		this.socket = new WebSocket(
			`ws://localhost:3000`,
			[myUUID, pass, "1.0.1"] // Ugly hack to send auth information and version to the server.
		);

		// Listen for messages
		this.socket.addEventListener('message', (event) => {
			const updates = JSON.parse(event.data)
			// uncomment the line below to log all updates from the server
			console.log('updates from server ', updates);

			updates.forEach(update => {
				const data = update.data
				switch (update.type) {
					case "drone": // information about a drone
						const existingCharacter = activeCharacters[data.UUID]
						if (existingCharacter) {
							existingCharacter.gameState = data
						} else {
							const sprite = this.add.image(data.x * 32, data.y * 32, 'player')//.setDisplaySize(100, 100);
							activeCharacters[data.UUID] = {
								ownerUUID: data.ownerUUID,
								sprite: sprite,
								gameState: data,
							}
							if (data.ownerUUID == myUUID) {
								activeDroneUUIDs.push(data.UUID)
							}
						}
						break;
					case "noDrone": // drone no longer exists TODO: have the server give more information about why the drone is gone
						const droneToRm = activeCharacters[data.UUID]
						if (!droneToRm) return console.error("no droneToRm?", update)
						droneToRm.sprite.destroy()
						delete activeCharacters[data.UUID]
						break;
					case "pro": // a projectile exists
						const projectile = projectiles[data.id]
						if (projectile) {
							projectile.gameState = data
						} else {
							const sprite = this.add.image(data.x * 32, data.y * 32, 'projectile')
							projectiles[data.id] = {
								sprite: sprite,
								gameState: data,
							}
						}
						break;
					case "noPro": // a projectile no longer exists
						const proToRm = projectiles[data.id]
						if (!proToRm) return console.error("no proToRm?", update)
						proToRm.sprite.destroy()
						delete projectiles[data.id]
						break;
						// TODO: add a chat
					case "chat":
						outputMessage(data.name, data.msg)
					default:
						break;
				}
			});
		});

		document.querySelector("#chat-form").addEventListener('submit', (e) => {
			e.preventDefault();
			// Get message text
			let msg = e.target.elements.msg.value.trim()
			if (!msg) {
				return false;
			}

			socket_stream.push({
				type: "chat",
				msg: msg,
			})
			// Clear input
			e.target.elements.msg.value = '';

			e.target.elements.msg.focus();
		});

		this.input.keyboard.on('keydown', (event) => {
			if (event.key == " ") {
				if (!activeDroneUUIDs[0]) return
				socket_stream.push({
					type: "move",
					data: {
						DUUID: activeDroneUUIDs[0],
						x: camPos.x / 32,
						y: camPos.y / 32,
					},
				})
			}
			keysPressed[event.key] = true
		});
		this.input.keyboard.on('keyup', (event) => {
			keysPressed[event.key] = undefined
		});
		this.input.on(Phaser.Input.Events.POINTER_DOWN, (pointer) => {
			const { worldX, worldY } = pointer
			
			for (let i = 0; i < activeDroneUUIDs.length; i++) {
				const drone = activeCharacters[activeDroneUUIDs[i]]
				socket_stream.push({
					type: "shoot",
					data: {
						DUUID: activeDroneUUIDs[i],
						rad: Math.atan2(worldY / 32 - drone.gameState.y, worldX / 32 - drone.gameState.x),
					},
				})
			}
		})
		this.input.on(Phaser.Input.Events.POINTER_UP, (pointer) => {
			const { worldX, worldY } = pointer
			
			for (let i = 0; i < activeDroneUUIDs.length; i++) {
				const drone = activeCharacters[activeDroneUUIDs[i]]
				socket_stream.push({
					type: "shoot",
					data: {
						DUUID: activeDroneUUIDs[i],
					},
				})
			}
		})
		cam = this.cameras.main
		cam.zoom = 1.5
		this.loop()
	}

	// 10 Times a second
	// if socket_stream has something socket.emit it
	loop() {
		if (this.socket.readyState == 1 && socket_stream.length != 0) {
			let actions = socket_stream.slice(0, 10)
			socket_stream.splice(0, 10)
			console.log("actions", actions)

			this.socket.send(JSON.stringify(actions))
		}
		setTimeout(() => { this.loop() }, 100); // continue the loop
	}

	// this runs every frame
	update() {
		const DeltaTime = secondsSinceLastFrame()

		// Smooth movement for projectiles and characters
		for (const key in projectiles) {
			const pro = projectiles[key];
			smooth(DeltaTime, pro.sprite, pro.gameState.speed * 32, pro.gameState.x * 32, pro.gameState.y * 32)
		}
		for (const key in activeCharacters) {
			const character = activeCharacters[key];
			smooth(DeltaTime, character.sprite, character.gameState.speed * 32, character.gameState.x * 32, character.gameState.y * 32)
		}
		
		// Control over the camera
		const u = keysPressed["w"] // up
		const d = keysPressed["s"] // down
		const l = keysPressed["a"] // left
		const r = keysPressed["d"] // right

		// if a control
		if (u || d || l || r) {
			// do nothing for opposite controls
			if (u && d && l && r) {
				return
			} else if (u && d && !l && !r) {
				return
			} else if (!u && !d && l && r) {
				return
			}
			// update camera
			if (u) camPos.y -= 5
			if (d) camPos.y += 5
			if (l) camPos.x -= 5
			if (r) camPos.x += 5
		}

		if (!cam) return
		cam.pan(camPos.x, camPos.y, 100, 'Linear')
		document.querySelector("#camdata").innerHTML = `${camPos.x} ${camPos.y}`
	}
}

// start the game
function start() {

	var scene = new Example()

	var game = new Phaser.Game({
		type: Phaser.AUTO,
		width: 800,
		height: 600,
		scene: [ scene ]
	});
}
</script>
</html>