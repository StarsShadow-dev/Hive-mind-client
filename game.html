<!DOCTYPE html>
<html>
<head>
	<script src="phaser.js"></script>
	<title>hive mind</title>
	<style>
		p#camdata {
			position: absolute;
			color: white;
		}
	</style>
</head>
<body>
	<form id="login">
        <div class="form-control">
            <label for="UUID">UUID</label>
            <input
            type="text"
            name="UUID"
            id="UUID"
            placeholder="Enter UUID"
            autocomplete="off"
            required
            />
        </div>
        <div class="form-control">
            <label for="token">token</label>
            <input
            type="text"
            name="token"
            id="token"
            placeholder="Enter token"
            autocomplete="off"
            required
            />
        </div>
        <button type="submit">start</button>
    </form>
</body>
<script>
var myUUID
var activeDroneUUID
var socket
var lastFrameTime
var cam

var keysPressed = {}
var activeCharacters = {}
var projectiles = {}
var camPos = {
	x: 0,
	y: 0,
}

var pressed_keys = []
var socket_stream = [
	{
		type: "make",
	}
]

document.querySelector("#UUID").value = localStorage.getItem("UUID")
document.querySelector("#token").value = localStorage.getItem("token")
document.querySelector("#login").addEventListener('submit', (e) => {
	e.preventDefault();
	const UUID = e.target.elements.UUID.value.trim()
	const token = e.target.elements.token.value.trim()
	console.log(e.target.elements)
	if (UUID && token) {
		socket = new WebSocket(
			`wss://quiet-inquisitive-epoch.glitch.me`,
			[UUID, token] // Ugly hack to send auth information to the server.
		);
		socket.onopen = () => {
			localStorage.setItem("UUID", UUID)
			localStorage.setItem("token", token)
			document.querySelector("body").innerHTML = `<p id="camdata"></p>`
			myUUID = UUID
			start()
		}
	} else {
		document.querySelector("body").innerHTML = "could not get your ID or token"
	}
});

// get the distance between point1 and point2
function getDistance(point1, point2) {
	return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
}

function secondsSinceLastFrame() {
	if (lastFrameTime == 0) {
		lastFrameTime = Date.now();
		return 0;
	}
	const currentTime = lastFrameTime;
	lastFrameTime = Date.now();
	return (lastFrameTime - currentTime) / 1000;
}

// Work in progress function to smooth out unpredictability in the netwerk
function smooth(DeltaTime, sprite, x, y) {
	const distance = getDistance(
		{ x: sprite.x, y: sprite.y }, 
		{ x: x, y: y }
	)
	if (distance > 3) {
		let distanceToTravel = DeltaTime + 3;
		const angle = Math.atan2(y - sprite.y, x - sprite.x);

		sprite.x += distanceToTravel * Math.cos(angle)
		sprite.y += distanceToTravel * Math.sin(angle)
	} else if (distance <= 3) {
		let distanceToTravel = DeltaTime + distance / 10;
		const angle = Math.atan2(y - sprite.y, x - sprite.x);

		sprite.x += distanceToTravel * Math.cos(angle)
		sprite.y += distanceToTravel * Math.sin(angle)
	}
}

class Example extends Phaser.Scene {
	constructor() {
		super();
	}

	preload() {
		// preload images

		// environment

		// Characters
		this.load.image('player', 'assets/player.png');
		this.load.image('projectile', 'assets/projectile.png');

		this.load.spritesheet('na', 'assets/NodeAtlas.png', { frameWidth: 16, frameHeight: 16 });
	}

	create() {
		this.add.image(0, 0, 'na', 0);
		this.add.image(0, 16, 'na', 0);

		this.add.image(16, 0, 'na', 0);
		this.add.image(16, 16, 'na', 0);

		// Listen for messages
		socket.addEventListener('message', (event) => {
			const updates = JSON.parse(event.data)
			console.log('updates from server ', updates);

			updates.forEach(update => {
				const data = update.data
				switch (update.type) {
					case "newDrone":
						const sprite = this.add.image(data.x * 16, data.y * 16, 'player')//.setDisplaySize(100, 100);
						activeCharacters[data.UUID] = {
							ownerUUID: data.ownerUUID,
							sprite: sprite,
							x: data.x * 16,
							y: data.y * 16,
						}
						if (data.ownerUUID == myUUID) {
							activeDroneUUID = data.UUID
						}
						break;
					case "moveDrone":
						const existingCharacter = activeCharacters[data.UUID]
						if (!existingCharacter) return console.error("no existingCharacter to move")
						existingCharacter.x = data.x * 16
						existingCharacter.y = data.y * 16
						break;
					case "pro":
						const projectile = projectiles[data.id]
						if (projectile) {
							projectile.x = data.x * 16
							projectile.y = data.y * 16
						} else {
							const sprite = this.add.image(data.x * 16, data.y * 16, 'projectile')
							projectiles[data.id] = {
								sprite: sprite,
								x: data.x * 16,
								y: data.y * 16,
							}
						}
						break;
					case "noPro":
						const proToRm = projectiles[data.id]
						if (!proToRm) return console.log("no proToRm?")
						proToRm.sprite.destroy()
						delete projectiles[data.id]
						break;
				
					default:
						break;
				}
			});
		});

		this.input.keyboard.on('keydown', (event) => {
			if (event.key == " ") {
				socket_stream.push({
					type: "move",
					data: {
						UUID: activeDroneUUID,
						x: camPos.x / 16,
						y: camPos.y / 16,
					},
				})
			}
			keysPressed[event.key] = true
		});
		this.input.keyboard.on('keyup', (event) => {
			keysPressed[event.key] = undefined
		});
		this.input.on(Phaser.Input.Events.POINTER_DOWN, (pointer) => {
			const { worldX, worldY } = pointer
			
			const drone = activeCharacters[activeDroneUUID]
			socket_stream.push({
				type: "shoot",
				data: {
					UUID: activeDroneUUID,
					rad: Math.atan2(worldY / 16 - drone.y / 16, worldX / 16 - drone.x / 16),
				},
			})
		})
		cam = this.cameras.main
		cam.zoom = 1.5
		this.loop()
	}

	// 10 Times a second
	// if socket_stream has something socket.emit it
	loop() {
		const stream_length = socket_stream.length

		if (stream_length != 0) {
			let actions = socket_stream.slice(0, 10)
			socket_stream.splice(0, 10)
			console.log("actions", actions)

			socket.send(JSON.stringify(actions))
		}
		setTimeout(() => { this.loop() }, 100); // continue the loop
	}

	// this runs every frame
	update() {
		const DeltaTime = secondsSinceLastFrame()

		// Smooth movement for projectiles and characters
		for (const key in projectiles) {
			const pro = projectiles[key];
			smooth(DeltaTime, pro.sprite, pro.x, pro.y)
		}

		for (const key in activeCharacters) {
			const character = activeCharacters[key];
			smooth(DeltaTime, character.sprite, character.x, character.y)
		}
		
		// Control over the camera
		const u = keysPressed["w"]
		const d = keysPressed["s"]
		const l = keysPressed["a"]
		const r = keysPressed["d"]

		// if a control
		if (u || d || l || r) {
			if (u && d && l && r) {
				return
			} else if (u && d && !l && !r) {
				return
			} else if (!u && !d && l && r) {
				return
			}
			if (u) camPos.y -= 5
			if (d) camPos.y += 5
			if (l) camPos.x -= 5
			if (r) camPos.x += 5
		}

		if (!cam) return
		cam.pan(camPos.x, camPos.y, 100, 'Linear')
		document.querySelector("#camdata").innerHTML = `${camPos.x} ${camPos.y}`
	}
}

// Start the game when you press the start button
function start() {

	var game = new Phaser.Game({
		type: Phaser.AUTO,
		width: 800,
		height: 600,
		scene: [ Example ]
	});
}
</script>
</html>